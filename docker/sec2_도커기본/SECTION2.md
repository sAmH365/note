* 서버에서의 컨테이너 개념
  * 다양한 프로그램, 실행환경을 컨테이너로 추상화하여 프로그램의 배포 및 관리를 단순하게 해준다.
* 도커 이미지와 컨테이너 정의
  * 컨테이너는 코드와 모든 종속성을 패키지화하여 응용 프로그램이 한 컴퓨팅 환경에서 다른 컴퓨팅 환경으로 빠르고 안정적으로 실행되도록 하는 소프트웨어의 표준 단위
  * 컨테이너 이미지
    * 코드, 런타임, 시스템 도구, 시스템 라이브러리 및 설정과 같은 응용프로그램을 실행하는 데 필요한 모든 것을 포함 하는 **실행 가능한 소프트 웨어 패키지**
    * 이미지를 사용해서 컨테이너를 만듦 -> 컨테이너는 이미지의 인스턴스
* 도커를 사용할 때 흐름
  * 도커 클라이언트(CLI) ----->  도커 Server(Daemon)
    * 도커 클라이언트에서 커맨드를 입력하면, 도커 서버는 이미지를 생성하든 그에 맞는 작업을 하게 된다.
    * cli을 입력했을 때 이미지 캐시 보관장소에 이미지가 없으면, 도커 허브에서 이미지를 가져온다.
* 도커와 기존 가상화 기술과의 차이
  * 가상화기술이 나오기전
    * 한대의 서버를 하나의 용도로만 사용 -> 남는 서버 공간 그대로 방치, 안정적 이지만 비효율적
  * 하이퍼 바이저 기반의 가상화 출현
    * 논리적으로 공간을 분할하여 VM이라는 독립적인 가상 환경의 서버 이용가능
    * 하이퍼 바이저는 호스트 시스템에서 다수의 게스트 OS를 구동할 수 있게 하는 소프트웨어
      * 하드웨어를 가상화하면서 하드웨어와 각각의 VM을 모니터링 하는 중간 관리자
  * 도커 컨테이너 VS 가상머신
    * 공통점
      * 기본 하드웨어에서 격리된 환경 내에 애플리케이션을 배치하는 방법
    * 차이점
      * 격리된 환경을 얼마나 격리 시키는지 차이
      * VM과 비교했을 때 컨테이너는 하이퍼바이저와 게스트 OS가 필요하지 않으므로 더 가볍다
      * 컨테이너 방식은 호스트 OS위에 이미지를 배포하기만 하면 되는데, VM은 애플리케이션을 실행하기 위해 VM을 띄우고 자원 할당 한다음, 게스트 OS를 부팅하여 애플리케이션을 실행하는 등 복잡하고 무겁다.
    * 도커 컨테이너
      * 같은 호스트이 다른 컨테이너와 동일한 커널을 공유
        * 컨테이너 내부에서 실행되는 프로세스는 호스트 시스템에서 볼 수 있다.
        * 가상 머신의 하이퍼 바이저 위에 게스트 OS들이 실행되는 방식이라 호스트 운영 체제와 게스트 운영체제는 독립되어 있다.
    * 도커 컨테이너 격리시키는 방법
      * 리눅스에서 쓰이는 CGroup(Control groups)과 네임스페이스(namespaces)
        * 컨테이너와 호스트에서 실행되는 다른 프로세스 사이에 벽을 만드는 리눅스 커널 기능
        * CGroup
          * CPU, 메모리, i/o 등 프로세스 그룹의 시스템 리소스 사용량을 관리
          * 어떤 애플리케이션이 사용량이 너무 많다면 C group에 집어 넣어서 CPU와 메모리 사용 제한 기능
        * 네임스페이스
          * 하나의 시스템에서 프로세스를 격리시킬 수 있는 가상화 기술
          * 별개의 독립된 공간을 사용하는 것처럼 격리된 환경을 제공하는 경량 프로세스 가상화 기술
* 이미지로 컨테이너 만들기
  * 이미지에 필요한것
    * 시작시 실행 될 명령어 (ex: `run kakaotalk`)
    * 파일 스냅샷 (ex: 카카오톡 파일)
  * Docker 클라이언트에서 docker run <이미지> 입력
* Cgroup, 네임스페이스를 도커환경에서 사용할 수 있는 이유
  * Cgroup, 네임스페이스는 리눅스 시스템에서만 이용할수 있는데 다른 os에서는?
    * 내부적으로 OS위에 리눅스 VM실행되고 있고, 그 위에 리눅스 커널이 올라가있어서 이 리눅스 커널 위에서 컨테이너들이 실행되고 있다.
    * `docker version` 명령어를 쳐보면 도커 엔진의 OS/Arch가 `linx/amd64`인 것을 확인할 수 있다.